
x release 0.4.4!

x update samples and tutorial on hamsterdb.com

x add grammar fixes for the tutorial

x replace return code INVALID_INDEX with NOT_INITIALIZED

x replace return code ENV_FULL with a generic HAM_LIMITS_REACHED

x unittest: fill an environment, till it returns HAM_LIMITS_REACHED

x new unittest: ham_new, create, ham_close, open, ham_close, ham_delete
    x for db
    x for env
    x for db in env

x new unittest: insert extended keys with 0xffff byte size, search for it

x new unittest: create with READ_ONLY -> fail INVALID_PARAMETER

x new unittest: 
    x set compare function
    x unset compare function
    x set prefix-compare function
    x unset prefix-compare function

x db1.c: 
    x should reopen the database file (then we have a call to ham_open,
        which is otherwise not tested on CE)
    x crashes!!
    x then test on CE

x new unittest: open with READ_ONLY; all write-functions must fail

x new unittest: open env with READ_ONLY; all write-functions must fail, 
        and write-functions of opened databases must fail, too

x new unittest: create file with pagesize 64kb, then open it

x new unittest: create env with pagesize 64kb, then open it

x new unittest: select a pagesize/keysize so less than 4 keys fit on a 
    page -> INV_KEYSIZE

x new unittest: create an environment, don't insert a database; close
    then open the environment as a database file (ham_open)

x new unittest: create an environment, insert a database; close
    then open the environment as a database file (ham_open)
        - should load the first available database

x new unittest: create an environment, insert two databases, delete the first
    then open the environment as a database file (ham_open)
        - should load the first available database

o new unittests for exclusive file locking
    x check on linux
    x check on windows
    o check on cygwin -- fails!



o more tests and performance checks with very large files - around 10 GB
    o write perl-script to generate the tests - w/o extended keys
    o write perl-script to generate the tests - w/  extended keys


o all unittests should run on Windows CE

o should backends have a version information? otherwise, the 32byte might be
    full, and we don't have room for an overflow area...

? freelist: keep lookaside-list of freelist pages (which freelist
    page starts at address xxxx?) to speed up the whole process
        o collect this idea in a file, but don't implement it (yet)

o add support for logical record numbers
    o new (persistent) flag
    o new call "u64_t ham_get_count(db)" (can also be used to get the last
        lrn)
    o stored at little-endian, but returned to the caller in host-endian
    o ham_insert: key must be NULL, (0/NULL) or (sizeof(u64_t)/!NULL)
        - in the last case, the key is filled (host-endian)

    o unittest: create, insert, close; reopen, insert, close -> must 
        continue the sequence

    o new sample db4
    o documentation
    o tutorial

    o needs new compare function for this database
    o make sure that keysize is >= 8 (set a good default keysize - needs
        benchmarks!)
    o btree insert: add optimization for "late splits" (don't split at 
        50% but select better pivot element - 95% or so)
    o write a new sample
    o enhance tutorial
    o new unittests (at least 20!)
    o new acceptance tests!


HAM_EXPORT ham_status_t
ham_get_count(ham_db_t *db, ham_u64_t *newid)
{
    ham_backend_t be;

    if (!db)
        return (db_set_error(db, HAM_INV_PARAMETER));

    be=db_get_backend(db);
    if (!be)
        return (db_set_error(db, HAM_NOT_INITIALIZED));

    *newid=be->be_get_count(be);
    return (db_set_error(db, 0));
}

static ham_status_t
be_get_count(btree_backend_t *be, ham_u64_t *count)
{
    ham_db_t *db=be_get_owner(be);
    ham_u8_t *p=db_get_indexdata(db);
    ham_u64_t c=*(ham_u64_t *)p[16]; // 16??

    *count=ham_db2h64(c);
    return (0);
}

static ham_status_t
be_set_count(btree_backend_t *be, ham_u64_t c)
{
    ham_db_t *db=be_get_owner(be);
    ham_u8_t *p=db_get_indexdata(db);
    *(ham_u64_t *)p[16]=ham_h2db64(c); // 16??

    return (0);
}

ham_insert:
    ham_u64_t newid;

    /*
     * only an empty key (0/0) is accepted - unless the key is 
     * user-allocated
     */
    if (db_get_rt_flags(db)&HAM_RECORD_NUMBER) {
        if (key->flags & HAM_KEY_USERALLOC) {
            if (!key->data || key->size!=sizeof(ham_u64_t))
                return (HAM_INV_PARAMETER);
        }
        else {
            if (key->data || key->size)
                return (HAM_INV_PARAMETER);
            /* allocate memory for the key */
            /* TODO */
        }

        /*
         * fill in the key - take care of endian-issues!
         */
        st=ham_get_count(db, &newid);
        if (st)
            return (st);
        newid++;
        newid=ham_h2db64(newid);
    
        memcpy(key->data, &newid, sizeof(newid));
        key->size=sizeof(newid);
    }


    /* continue as usually... */

    if (db_get_rt_flags(db)&HAM_RECORD_NUMBER) {
        /* insert failed: if !HAM_KEY_USERALLOC: key->data=0; key->size=0; */
        /*
         * on success: return record ID as host endian!
         */
        newid=ham_db2h64(newid);
        memcpy(key->data, &newid, sizeof(newid));
        ham_assert(ham_get_count(db)==newid);
    }

o release 0.4.5

