
o port to big-endian
    still a bug on big-endian: ./test 1/130.tst --overwrite=1 --pagesize=8192
    o test with valgrind
    o switch default endian to big endian - does it work on my local machine?

o monster.sh: test with massive page splits: pagesize=512 and
    keysize=128 (in-memory-db should be sufficient)

o release 0.4.1!

-----------------------------------------------------
-----------------------------------------------------

o logo!!

o create a webpage
    o contents are missing
        o front page: embed the hamster picture? or leave as is?
        o front page: add "news"-area
    o tutorial
        x also add docs about installation, compilation, porting
    o offer API doc and tutorial as pdf
    o ask someone to correct my english

o release 0.4.2!

-----------------------------------------------------
-----------------------------------------------------

o insert: es wird erst ein move der bte's gemacht, dann wird der 
    blob allokiert. andersrum wäre es besser, dann ist nix kaputt
    falls die allokation fehlschlägt

o fix a small valgrind bug
    valgrind --tool=memcheck --leak-check=full --show-reachable=yes 
        .libs/lt-test --file ../../testfiles/1/ext_060.tst 
        --inmemorydb=1 --verbose=1
    ==26699== 53 bytes in 1 blocks are definitely lost in loss record 1 of 1
    ==26699==    at 0x4A1EAC6: malloc (vg_replace_malloc.c:149)
    ==26699==    by 0x407745: _ham_mem_malloc (mem.c:25)
    ==26699==    by 0x40A92E: blob_allocate (blob.c:191)
    ==26699==    by 0x4135BF: key_insert_extended (keys.c:67)
    ==26699==    by 0x40E46B: my_insert_nosplit (btree_insert.c:520)
    ==26699==    by 0x40DD81: my_insert_in_page (btree_insert.c:274)
    ==26699==    by 0x40DCB3: my_insert_recursive (btree_insert.c:241)
    ==26699==    by 0x40DA0A: btree_insert_cursor (btree_insert.c:134)
    ==26699==    by 0x40DBBE: btree_insert (btree_insert.c:194)
    ==26699==    by 0x406C0F: ham_insert (hamsterdb.c:704)
    ==26699==    by 0x403717: my_execute (test.c:1168)
    ==26699==    by 0x4041FC: main (test.c:1855)

    tests/src/ext_060.tst: wenn das allerletzte erase drin ist, gibt's ein 
    leak. wenn nicht, gibt's keins.
    endet in btree_erase.c:1040 - wenn in einer internen page ein key 
    gelöscht wird, wird der record nicht gelöscht

o something is weird: database files are overwritten, but somehow this 
    is not reflected...

    cd samples
    ./db1 # creates test.db
    ./db2 test.db test2.db # prints: "database is empty", ok
    cat db3.c | ./db3 # creates/overwrites test.db
    ./db2 test.db test2.db # prints: "database is empty" ????
    rm *.db
    cat db3.c | ./db3 # creates/overwrites test.db
    ./db2 test.db test2.db # now the database is not empty!

o replace os_tell with os_get_filesize 

o release 0.4.3

-----------------------------------------------------
-----------------------------------------------------

o add file locking to enable simple concurrency:
    o either no locking at all
    o or exclusive locking
    o or shared locking when reading, excl. lock when writing

o test 1 writer, multiple reader scenarios

o release 0.4.4
    
-----------------------------------------------------
-----------------------------------------------------

o command line tools
    o ham_dump
        dumps keys and records
        --key-format=char|short|long|longlong|string|binary
        --key-length=<n>
        --data-format=char|short|long|longlong|string|binary
        --data-length=<n>
    o ham_info
        prints all statistics of the database header, number of items, 
        average key size, average data size, min/max etc
    o ham_recover
        gets the header-page, then the root-page, then goes down to the 
        first leaf; walks through all pages. if it's a leaf page: get the 
        blob, insert it in the new database. print all lost items/records
        to stdout.
    o ham_reorg
        for a reorganization (creates a new database with HAM_OPT_SIZE, 
        writes all items to the new database)

o do a complete source code review, or ask someone to do it
    are error numbers propagated correctly?
    what happens with errors during flush?
    what happens with errors during close?
    o rename some stuff
        o all static functions have the prefix "my_", they should
            become a better prefix (i.e. "bt_" for btree etc)
        o db.c has some backend-specific functions, maybe they should 
            be moved to the backend
    o check the TODOs in the source

o release 0.4.5 - should be stable!!
    increment libtool version to 0.1

