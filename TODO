 
I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------

As a user i want to run many Transactions in parallel with high performance.
I'm not interested in multiple threads (yet), although i may use several 
threads (but then i'll use synchronization in my own code).
==============================================================================

x cleanups: the backend structure does not need the function pointers. 
    simplify the whole interface!
    --> no, it's fine. the interface is clean and good as it is.

x be_set_dirty is not really required, is it? the flushes are always explicit
    --> no, not explicit. better leave it as is.

x db_compare_keys can return errors - do we really need this??
    --> yes, because extended keys access disk and caches

x log_t: allocator _alloc still needed? we have the Env pointer

o cleanup the cache - the garbagelist is not needed, and the age of the pages
    is also not needed (unless it turns out to improve the performance)
    o the cache should give preference to index pages

o journal->_lsn - no longer needed?

o log_entry_t: txn_id still needed?

o do some profiling - i am afraid that changeset_get_page() is not efficient
    enough; maybe a hash table is better?

o refactor cursor; separate backend-cursor and txn-cursor; make the 
    o rename bt_cursor -> btree_cursor?

    o cursor_has_duplicates: move to cursor.c; often is used in 
    boolean form, but should be: true if >1, false if <=1

    o cleanups: the cursor does not need the function pointers. 
        simplify the whole interface!

    o cursor and btree-cursor: each have their own dupecache; merge them

    o "uncoupled" cursor part of the frontend. When coupling, btree AND txn 
    have to couple, and check if it was erased in the meantime!
    or: - cursor tracks state if it's coupled to txn or btree
        - when coupling, caller can select whether to couple to btree or txn
            cursor_couple(TXN || BTREE)
        o the btree_cursor.* files need some rework/reformatting/renaming
        o also, txn_cursor.c is not isolated well enough; it sometimes 
            accesses the btree_cursor. 

        o extend/reorganize the cursor code. add a dynamic list of 
            duplicates for the cache (and in debug-mode also track the key
            that is coupled).
            high level cursor can manage
                - its state (nil; coupled to txn; coupled to btree)
                - implements the local functions
                - the duplicate cache (optional, only if txn's are used)
                - parent of the txn-cursor
                - parent of the btree-cursor
    o use a single dupecache for btree and txn-tree (currently, the btree
        cursor has it's own)
    o completely rewrite _local_cursor_move

o add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

o hamsterdb.com
    x add twitter feed
    o API documentation: don't link to "modules" but to startup page, update
        with newest version
    o crupp.de: do a backup of the database
    . google +1 button
    . can we use something like Aller.font?

o update documentation
    x in header file
    o in the wiki
        o don't forget to list all functions that are currently disabled
            w/ txn's -> sorting dupes, approx. matching, ...
        o transactional behavior/conflicts of duplicate keys
    o in the wiki: start with internal documentation
        o transactions
        o architecture
        o btree
        o journal/log
        o cache
        o I/O
        o unittests
        o monstertests - how to use them?

o fully (!) automize the whole release process for unix; the result (on
    success) are the following files:
    o tar-ball
    o the README
    o the documentation as a tar
    o the Changelog
    o the release notes (a template)
    o the output (xml) of the monster tests

. port to WinCE

x monster-test
    x track memory consumption
    x add/finalize xml output

. need a function to get the txn of a conflict (same as in v2)

o how can we extend the monster-tests to have reliable tests for transactions?

o improve journalling and get rid of the physical log as much as possible
    o recovery: recreate all pending transactions (if requested)
    o unittests
    o merge log and journal. There's no need to have two different files. 
        For all 'simple' operations (insert, erase w/o SMO) a journal entry is 
        sufficient. For all other operations we can just append the log
        entries to the journal file. in such cases, the journal entry of an
        insert or erase (w/ SMO) contains the modified pages as well.
        ??? really? does that simplify things?
    o api function to get a list of pending transactions after recovery
    o be careful - even if the btree operations are atomic, the whole
        insert/erase is not because it also affects the blob area and the
        freelist (and maybe the header page, if the root page address is
        modified)
        -> this is where we might have to rewrite the btree insert algorithm

o test with lessfs (and add lessfs to the monster testsuite)
    o test with reboots - like those that made problems with lessfs

x if recovery is enabled: before flushing the changeset, patch the lsn in
    the page header (it fits in 8 free bytes). in the previous release we 
    stored the lsn in the log file header. this can be removed; use the 
    lsn in the page header for recovery.
    --> why?? i think the current solution is good enough

. if memory consumption in the txn-tree is too high: flush records to disk
    (not sure if this should get high priority)

o new flag for transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the blob, not
    to the log. the log will only contain the rid.
    o document this (and also the drawback - that an abort will lose the 
        blobs and they cannot be reused
    -> this affects all temporary ham_insert-transactions 
    (not sure if this should get high priority)

o ham_txn_begin receives Environment handle, not Database handle
    o need a new parameter (reserved) for parent txn
    o need a new parameter for txn name (string)
        o this needs a getter function
    o update unittests/add new tests
    o update C++ API
    o rewrite auto-abort/auto-commit -> move to env
    o what happens if a database is closed, but it's modified by a txn
        that is still active? -> error (verify this!)

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created

o extkeys: don't use txn_id for the 'age', use lsn instead

o opnode: use key instead of key* (pointer) - this saves one allocation 
    per node

. allow use of transactions without a log/journal

. allow use of transactions for in-memory databases

o should the changeset become part of the log? it would make sense

o many unittests (i.e. LogHighLevelTest) create an allocator but do not use it

XXXXXXXXXXXXXXXXXXXXX release 2.0.0 rc2 UNSTABLE XXXXXXXXXXXXXXXXXXXXXXXXXXX

o when flushing a changeset: sort by offset, use writev()

o flush transactions in background

. have a flag to disable flushing of logfiles/journal files (or flush them 
    async.)

o continue as described in integrate-ham2.txt...


