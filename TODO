 
I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------

As a user i want to run many Transactions in parallel with high performance.
I'm not interested in multiple threads (yet), although i may use several 
threads (but then i'll use synchronization in my own code).
==============================================================================

x new code is only active if HAM_ENABLE_TRANSACTIONS is specified; 
    otherwise everything stays as is
    x allow more than one txn in parallel
    x don't need DO_NOT_NUKE_PAGE_STATS as flag for txn_abort/commit
    x env_flush_committed_txns() - must clear txn from list
    x rewrite auto-abort/auto-commit

o manage all transactions
    x integrate existing rb-tree code from hamsterdb2
        x rb.h
        x txns are linked lists (chronological) 
        x this tree stores operations for each key
            x create txn_op structure
            x create insert(update) and erase operations
            x each op is stored chronologically in the txn AND in the rb-node
        x each database has such a tree
    x remove the whole transaction handling from the low-level page
        i/o routines
        x also remove refcounts in the pages, replace with
            page_lock
            page_unlock
            page_is_locked
        x remove PAGE_LIST_TXN
    x remove env_get_txn, env_get_txn_id
        distinguish: on high level, we have multiple txns
        on low level, we use the lsn for file-io routines
            x extkeys.c - extkey_set_txn_id: replace with lsn
            x keys.c: move page_get_btree_node functions to btree.c; can we
                move everything else into util.c?
            x make sure that page_get_btree_node() is only called in
                btree_*.c 
                key_compare_pub_to_int
                key_compare_int_to_int
            x btree_close_cursors - actually in use? - yes
            x db.h - cleanup high level i/o interface
            x util.h - cleanup 
            x blob.h - cleanup interface if possible
            x page.h - cleanup 
            x rename int_key_t to btree_key_t
            x rename statistics.c to btree_stats.c (and rename the functions)

    x rewrite ham_insert
        x need functions to create trees/nodes/ops
                tree=txn_tree_get_or_create(db)
                node=txn_node_get_or_create(tree, key)
                op=txn_op_create(node, flags, record) -> store the full record!
                    -> all ops are in two linked lists!
        x if transactions are disabled: immediately write to disk, no
            temp transactions are needed
        x each modified database gets its own txn tree when its modified
            in a transaction
        x for now do not write the blob to disk but keep it in memory
        x otherwise insert into transaction tree
        x need a new error code HAM_TXN_CONFLICT
        x check for transaction conflicts (similar to ham2)

    x txn_free: discard the tree and everything that's allocated

    x implement env_flush_committed_txns()

    x add unittests for all the stuff I did so far
        x structure test: txn
        x structure test: txn_tree
        x structure test: txn_node
        x structure test: txn_op
        x allow multiple txn's in parallel and make sure that they
            are linked correctly
        x create a txn-tree for a txn/db twice and make sure that it's
            only created once
        x create multiple trees and make sure that they 
            are linked correctly
        x create a txn-node for a txn/db/key twice and make sure that it's
            only created once
        x create multiple nodes and make sure that they 
            are linked correctly
        x create an op for a txn-node
        x create multiple ops and make sure that they 
            are linked correctly in the node
        x test all potential conflict scenarios

    x tree is property of db, not of env (-> O(1))
        optree->_next really needed? - no
    x when op is deleted: update the node structure (op_next_in_node)
    x when op is deleted and node is empty: remove node from tree
    x when node is removed and tree is empty: remove tree from db
        or better: remove tree when db is closed
    x fix all unittests/memleaks
    x some structural changes -> need unittests
        txn_op_t previous_in_txn
        txn_op_t previous_in_node
        txn_op_t node
        txn_optree_node_t tree
    x who allocs/frees the key in the node? - streamline

    x rename txn_optree_node_t to txn_opnode_t (consistent with txn_optree_t)

    x rewrite ham_find
        x if transactions are disabled: immediately read from disk
        x otherwise go through transaction trees
        x add unittests

    x do not conflict if the same transaction already modified the key!

    x rewrite ham_erase
        x each modified database gets its own txn tree when its modified
            in a transaction
        x if transactions are disabled: immediately write to disk, no
            temp transactions are needed
        x otherwise go through transaction trees
        x add unittests

    x add new unittests

    x review page.h - anything that we do not need? (i.e. dirty_txn?) - no

    o ham_find: when retrieving a record, do not copy the original 
        record-pointer; we need a deep copy instead because this record
        pointer may be flushed and become invalid.

    o more pending cleanups
        o remove env_get_txn, env_get_txn_id
        o extkeys: don't use txn_id for the 'age', use lsn instead

    o rewrite enumeration code
        -> some just need to enumerate over btree
        -> but others need to enumerate over txns as well

o make sure all unittests are running

o recovery: auto-aborts all pending transactions (same behavior as now)

o implement partial reads through transaction tree - will have to 
    consolidate them

o implement approx. matching through transaction tree - will have to 
    consolidate rb-tree and btree to look for the "closest" key

o implement direct access - how, if the transaction tree is flushed??
    (but in-memory access w/ transactions is anyway not yet supported -
    write unittest to assert that it doesn't work)

o support cursors!!!
    - when flushing a transaction, and a cursor is pointing into the txn
        node: uncouple the cursor!

XXXXXXXXXXXXXXXXXXXXX release first version, merge with master XXXXXXXXXXXXXXX

o each operation writes a journal entry (however, we still keep the logical
        journal in parallel, otherwise the unittests will fail completely)
        o write entry for db_find
        o write entry for db_insert
        o write entry for db_erase
    o api function to get a list of pending transactions
    o recovery: recreate all pending transactions (if requested)
    o unittests

o ham_txn_begin receives Environment handle, not Database handle
    o need a new parameter (reserved) for parent txn
    o need a new parameter for txn name (string)
    o update unittests/add new tests
    o update C++ API
    o rewrite auto-abort/auto-commit -> move to env

o new API to retrieve the currently active transactions
    o already exists
    o needs unittests

o continue as described in integrate-ham2.txt...
