I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

==============================================================================

o Investigate failure in erlang qc-tests

o master branch has new patches; rebase v2 and topic/next, topic/txn etc
    -> rename topic/txn to topic/next, remove topic/txn

x Win32: ham_recover is missing in the .zip-file

o Win32: compile a newer boost version - the current one requires a few hacks
    because it is too old

o Win32: investigate performance discrepancies between Linux and Windows;
    Linux is much faster. Tested even against 2.1.10, which suffers from
    the same bad performance. The regression is therefore not caused by
    boost::async or other recent changes. It seems that PRO does NOT suffer
    from this (check again!)

o refactoring of the whole transaction-mess
    goals:
      1. transactions can be created on the stack
      2. transactions are no longer a linked list
      3. transaction operations are not handled in a separate tree but
            are attached to the btree nodes
      4. remove that awful complexity that currently exists
      5. make everything faster

    implementation steps:
      x create new structure DeltaUpdate - identical to TransactionOperation,
            but part of the Btree sources
      x SortedDeltaUpdates is a vector which is sorted by key and attached to
            a node (the node manages this vector)
      x UnsortedDeltaUpdates is a vector which is appended to only, no lookup
      x Each Transaction has a UnsortedDeltaUpdates
      x Each DeltaUpdate has a state (committed or aborted, txn-id)
      x As soon as a Transaction is committed or aborted then the state of
            its DeltaUpdates is updated
      x insert: check/update DeltaUpdates instead of TxnTree
        x perform a lookup on that key
        x check for conflict or if the key was erased before
        x if not: insert a new DeltaUpdate
      x erase: check/update DeltaUpdates instead of TxnTree
      x find: check DeltaUpdates instead of TxnTree
      x simple tests should work (no cursors, no splits/merges)
      x If a node is split or merged then the DeltaUpdates are re-distributed
            between the nodes
      x cursor: consolidate DeltaUpdates instead of TxnTree
        x insert
        x find
        x erase
        x move first
        x move last
        x move next
        x move previous
      x handle duplicate keys
        x consolidate DUs/btree duplicates
            x class DupeCacheLine -> struct Duplicate
            x struct Duplicate can refer to DeltaUpdate
            x DuplicateCache becomes typedef std::vector<Duplicate>
            x implement update_duplicate_cache
        x cursor: get duplicate count
        x cursor: move_first
        x cursor: move_last
        x cursor: move_next (att. HAM_ONLY_DUPLICATES, HAM_SKIP_DUPLICATES)
        x cursor: move_previous (att. HAM_ONLY_DUPLICATES, HAM_SKIP_DUPLICATES)
      x fix regressions
        x Cursor-dupes/*
        x Cursor-notxn/*
        x Cursor-temptxn/*
        x Cursor-longtxn/switchDirectionsMixedStartInTxnTest
        x Cursor-longtxn/findTxnThenMoveNextTest
        x Cursor-longtxn/findTxnThenMoveNextTest
        x Cursor-longtxn/findTxnThenMoveNext2Test
        x Cursor-longtxn/findTxnThenMovePreviousTest
        x Cursor-longtxn/findTxnThenMovePrevious2Test
      x implement approx. matching

      x implement recovery! but how?
          simplest solution: if a transaction is flushed then all DUs will
          be flushed as well. this is the current implementation with the
          TransactionOperations.
        x LocalTransactionManager stores counters/sizes of committed operations
            (m_queued_bytes_for_flush etc); they are currently not correctly
            updated. Are they required? -> yes!
        x if a cursor is attached to a DeltaUpdate: simply "uncouple" it!
        x fix Journal/*

==========================================================
Cursor-notxn/insertFindMultipleCursorsTest
- when deltas are flushed, the DeltaUpdate->action pointer is null'ed
- when moving a cursor, it accesses DeltaUpdate->action and segfaults
- when flushing the DeltaAction: invalidate/uncouple all Cursors that are
    coupled to its DeltaUpdate! (but how? the DeltaBinding has to store
    multiple cursors!)

Approx/issue52Test
- when coupling to a DU: uncouple from the previous DU!
- implement LocalDatabase::maybe_remove_delta_update_from_node
==========================================================

      o merge committed deltas, free aborted deltas
        o make sure that attached cursors are coupled to the new btree item
        o if keys are deleted then 'nil' the cursors
            o this needs to be documented b/c it's a semantic change (really?)

      o splitting deltas does not yet work; the pivot position is calculated
        for the btree node, not for the deltas! -> double-check!

      o the state management is a mess; clean it up
        The cursor can have the following states:
            - coupled to a page, a DeltaUpdate and a duplicate index
            - coupled to a page, a btree slot and a duplicate index
            - nil (not coupled to a page)
        A few helper functions are required:
            - couple_to_delta_update(Page *, int du, int duplicate);
            - couple_to_btree_slot(Page *, int slot, int duplicate);
            - set_to_nil()
        - then change update_duplicate_cache, sync (remove additional
            parameters), and no longer misuse BtreeCursor.m_state
        - remove kStateAttached (really? how do we differentiate?)

      o remove TransactionOperation, -Node, -Index, -Cursor, rb.h etc
        o once more refactor; clean up separation between BtreeCursor and
            LocalCursor; maybe move duplicate handling to LocalCursor?
            maybe move DeltaUpdate handling to a DeltaUpdateCursor?
            also try to remove duplicate code, clean up/optimize the flow

      o create temp transactions on the stack
        -> temp transactions are not stored in a linked list
        o (non-temp) transactions form a single linked list, not a double one

      o create temp cursors on the stack
        o cursors should form a single-linked list
        o append at front
        o cursors on stack are not added to the list
        o ALWAYS create a cursor when performing an operation?

      o github issue tracker has more bugs regarding approx. matching
      o should we fix these? not sure if it makes sense
            o Cursor-dupes/insertAfterTest (commented out)
            o Cursor-dupes/insertBeforeTest (commented out)
      o new tests:
            BEGIN T1; INSERT K1; ERASE K1; FIND K1; -> error
            BEGIN T1; INSERT K1; ERASE K1; FIND K1 in T2; -> conflict
            BEGIN T1; INSERT K1; ERASE K1; COMMIT T1; FIND K1; -> error
            BEGIN T1; INSERT K1; ERASE K1; COMMIT T1; FIND K1 in T2; -> error

      o when moving cursors, they should attach themselves to the current
            Action. And when the action is flushed it needs to "flush" the
            cursors as well!
            BEGIN T1; INSERT_CURSOR C1, K1; FIND_CURSOR C2, K1; COMMIT T1;
                -> make sure C1, C2 point to the same key
            BEGIN T1; FIND_CURSOR C2, K1; ERASE_CURSOR C1, K1;COMMIT T1;
                -> make sure C1, C2 are both nil

      o ham_get_key_count: visitor class in btree_index.cc does not evaluate
        delta updates correctly (see comments in the class)

      o run valgrind tests
      o run monster tests
      o run performance tests

o unittest: run Cursor-notxn/getRecordSizeTest, but each duplicate should
    have a different size and data. Then verify both!

o if a node does not have any deltas then lookup functions can behave in the
    same way as if transactions were disabled (-> call btree functions!)

o split LocalDatabase in LocalTransactionalDatabase, and LocalEnvironment
    in LocalTransactionalEnvironment? same for cursors
    -> would introduce a few new classes, but make the implementation much
        cleaner
    -> however, in the future there might be DeltaUpdates even if TXNs are
        disabled; and this would defeat the whole purpose of the split

o create a macro HAM_ALWAYS_INLINE
    MSVC: __forceinline
    GCC/Clang: __attribute__((always_inline))
    everything else: inline
 
. the BtreeIndex methods should get a BtreeCursor as a parameter, not a
    LocalCursor
