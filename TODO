 
I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------

As a user i want to run many Transactions in parallel with high performance.
I'm not interested in multiple threads (yet), although i may use several 
threads (but then i'll use synchronization in my own code).
==============================================================================

x cleanups: the backend structure does not need the function pointers. 
    simplify the whole interface!
    --> no, it's fine. the interface is clean and good as it is.

x be_set_dirty is not really required, is it? the flushes are always explicit
    --> no, not explicit. better leave it as is.

x db_compare_keys can return errors - do we really need this??
    --> yes, because extended keys access disk and caches

x log_t: allocator _alloc still needed? we have the Env pointer

x log_entry_t: txn_id still needed?

x journal->_alloc not needed, it's part of the Env

x journal->_lsn - no longer needed?
    ---> no, it's still required

x cleanup the cache - the garbagelist is not needed, and the age of the pages
    is also not needed (unless it turns out to improve the performance)
    x remove the garbage list
    x the cache should give preference to index pages
    x cache->_timeslot
    x cache_reduce_page_counts
    x update_page_access_counter
    x DB_NEW_PAGE_DOES_THRASH_CACHE

x review non-cursor operations - make sure that the txn-layer is
    clearly separated from non-txn layers (db and backend);
    also make sure that in case of errors the changeset and the local txn
    are correctly cleaned up
    x close
    x get_parameters
    x check_integrity
    x get_key_count
    x insert
    x erase
    x find

o refactor cursor; separate backend-cursor and txn-cursor; make the 
    x rename bt_cursor -> btree_cursor?

    x cursor_has_duplicates: move to cursor.c; often is used in 
        boolean form, but should be: true if >1, false if <=1

    x review all cursor functions, make sure there's a clear separation
        between txn-cursor and btree-cursor and the upper layer;
        also make sure that in case of errors the changeset and the local txn
        are correctly cleaned up

    o cleanups: the cursor does not need the function pointers. 
        simplify the whole interface!
        x btree_cursor functions should receive a btree_cursor as a 
           parameter which does NOT include the parent functions, but 
           which includes a pointer to the parent cursor
           that way the parent functions can be removed step by step
            x cursor_create
            x cursor_close
            x cursor_clone
            x cursor_insert
            x cursor_find
            x cursor_erase
            x cursor_get_duplicate_count
            x cursor_overwrite

        x unify the "is_nil"-handling and the coupling
            x use getter/setter instead of flags
                x coursor_is_nil
                x coursor_set_to_nil
                    x one function for 3 states (txn, btree, both)
                    x env.c:1640
                x coursor_is_coupled_to_btree
                x coursor_is_coupled_to_txnop
                x coursor_couple_to_btree
                x coursor_couple_to_txnop
                x it seems there are some places where a txn-cursor->parent
                    points to a cursor, but cursor->txn_cursor is a different
                    structure. verify with asserts (i.e. in 
                    txn_cursor_get_parent) -- no, it's fine
            x valid states: nil, btree, txn; but btree maintains its own 
                coupling; currently there are TOO MANY FLAGS!! clean them up!
                -> no, should be ok for now

        o cleanup cursor.h 
            o which functions are required to be public, which are not? 
            o make sure that the btree_cursor* and txn_cursor* functions are 
                not called from the upper layers 
            o get rid of the function pointers
                o cursor_create
                o cursor_close
                o cursor_clone
                o cursor_insert
                o cursor_find
                o cursor_erase
                o cursor_get_duplicate_count
                o cursor_overwrite
                o cursor_move
            o add documentation

        o also cleanup btree_cursor.h
            o remove functions that are not required
            o add documentation

        o make btree_cursor similar to txn_cursor and include it into
           ham_cursor_t -> need to remove all the casts - this is a big change!
            o remove SIZEOF_CURSOR in cursor.c
        o unify the dupe caches - btree cursor and upper layer cursor have 
            their own dupe-caches each (or not? after all it's possible that
            a txn-cursor is coupled to a different key than the btree,
            and destroying the dupecache could bring problems)
        o cursor_set_lastop: store operation, direction, last compare value
            of txn-key vs. btree-key?

    o completely rewrite _local_cursor_move

    o there are a lot of areas where a btree cursor is uncoupled, just to 
        retrieve the key and to couple the txn-key. that's not efficient

    o cleanup txn_cursor_insert, _erase, _find, _overwrite - move to cursor.c,
	simplify the functions in db.c

    o unittests for all new functions in cursor.h
    o documentation in cursor.h!

o do some profiling - i am afraid that changeset_get_page() is not efficient
    enough; maybe a hash table is better?

o performance: check for DB_NEW_PAGE_DOES_THRASH_CACHE in env.c. If the page
    is only required once then it should be inserted at the tail of the
    totallist, like a page that was not accessed for a very long time

o add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

o make sure that all tests are successful and performance is as good as 
    before (1.1.12)

o should the changeset become part of the log? it would make sense

o opnode: use key instead of key* (pointer) - this saves one allocation 
    per node

o many unittests (i.e. LogHighLevelTest) create an allocator but do not use it

o also, if a unittest fails in ham_close (i.e. because a cursor was not closed)
    then teardown() is not called and all other tests fail b/c the file handle
    is still occupied

XXXXXXXXXXXXXXXXXXXXX release 2.0.0 rc2 UNSTABLE XXXXXXXXXXXXXXXXXXXXXXXXXXX

o hamsterdb.com
    x add twitter feed
    o API documentation: don't link to "modules" but to startup page, update
        with newest version
    o crupp.de: do a backup of the database
    . google +1 button
    . can we use something like Aller.font?

o update documentation
    x in header file
    o in the wiki
        o don't forget to list all functions that are currently disabled
            w/ txn's -> sorting dupes, approx. matching, ...
        o transactional behavior/conflicts of duplicate keys
    o in the wiki: start with internal documentation
        o transactions
        o architecture
        o btree
        o journal/log
        o cache
        o I/O
        o unittests
        o monstertests - how to use them?

o fully (!) automize the whole release process for unix; the result (on
    success) are the following files:
    o tar-ball
    o the README
    o the documentation as a tar
    o the Changelog
    o the release notes (a template)
    o the output (xml) of the monster tests

. port to WinCE

x monster-test
    x track memory consumption
    x add/finalize xml output

o need a function to get the txn of a conflict (same as in v2)

o how can we extend the monster-tests to have reliable tests for transactions?

o improve journalling and get rid of the physical log as much as possible
    o recovery: recreate all pending transactions (if requested)
    o unittests
    o merge log and journal. There's no need to have two different files. 
        For all 'simple' operations (insert, erase w/o SMO) a journal entry is 
        sufficient. For all other operations we can just append the log
        entries to the journal file. in such cases, the journal entry of an
        insert or erase (w/ SMO) contains the modified pages as well.
        ??? really? does that simplify things?
    o api function to get a list of pending transactions after recovery
    o be careful - even if the btree operations are atomic, the whole
        insert/erase is not because it also affects the blob area and the
        freelist (and maybe the header page, if the root page address is
        modified)
        -> this is where we might have to rewrite the btree insert algorithm

o test with lessfs (and add lessfs to the monster testsuite)
    o test with reboots - like those that made problems with lessfs

x if recovery is enabled: before flushing the changeset, patch the lsn in
    the page header (it fits in 8 free bytes). in the previous release we 
    stored the lsn in the log file header. this can be removed; use the 
    lsn in the page header for recovery.
    --> why?? i think the current solution is good enough

. if memory consumption in the txn-tree is too high: flush records to disk
    (not sure if this should get high priority)

o new flag for transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the blob, not
    to the log. the log will only contain the rid.
    o document this (and also the drawback - that an abort will lose the 
        blobs and they cannot be reused
    -> this affects all temporary ham_insert-transactions 
    (not sure if this should get high priority)

o ham_txn_begin receives Environment handle, not Database handle
    o need a new parameter (reserved) for parent txn
    o need a new parameter for txn name (string)
        o this needs a getter function
    o update unittests/add new tests
    o update C++ API
    o rewrite auto-abort/auto-commit -> move to env
    o what happens if a database is closed, but it's modified by a txn
        that is still active? -> error (verify this!)
    o need to increase libtool version!

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created

o extkeys: don't use txn_id for the 'age', use lsn instead

. allow use of transactions without a log/journal

. allow use of transactions for in-memory databases

XXXXXXXXXXXXXXXXXXXXX release 2.0.0 rc3 UNSTABLE XXXXXXXXXXXXXXXXXXXXXXXXXXX

o when flushing a changeset: sort by offset, use writev()

o flush transactions in background

. have a flag to disable flushing of logfiles/journal files (or flush them 
    async.)

o continue as described in integrate-ham2.txt...


