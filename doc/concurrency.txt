    Concurrency

------------------

    This document describes the locking of latches, pages etc.

------------------

    hamster-db uses atomic operations and objects of the OS to provide
locking mechanisms. For synchronizing short and "fast" sequences of code,
two structures are provided: fast_mutex_t and fast_semaphore_t. Both
are handled in user-land. For longer sequences of code, mutex_t and
semaphore_t provide wrappers around OS-functions.

    fast_mutex_t and fast_semaphore_t are based on atomic operations. 
Their behaviour at runtime depends on the CPU, on which the lock is
requested. If the lock owner uses the same CPU as the process/thread, 
which requests the lock, the requesting process uses sched_yield() to wait. 
Otherwise, the requesting process waits in a "tight loop". 

    Pseudo-code:

    if lockowner.cpu==lockrequest.cpu:          -- same cpu
        while !lock.trylock():
            sched_yield();
    else
        while !lock.trylock():
            ;                                   -- do nothing

    The lock owner is identified by its thread-ID/process-ID and CPU id.

    On Linux, the CPU id can be queried with get_smp_processor_id(),
declared in <linux/smp.h>.
